\chapter{Introduction}
In the early days of computing, programmers had to work in offices. Personal computers allowed programmers to work at home as well. Laptops further expanded the working environment, and we often see people programming in coffee shops, terminals, trains, and airplanes. With ubiquitous mobile devices becoming increasingly popular, there is an opportunity to allow programmers to work in even more restrictive environments. While such small devices are unlikely to become the preferred working environment, they can be useful in circumstances where urgent action is required and other equipment is unavailable.

This scenario presents two major obstacles: first, the lack of a convenient keyboard; and second, the small screen space, which limits the amount of code that can be shown simultaneously. Some have advocated the creation of new programming languages for mobile platforms, but the cost of adopting a new language, with its related tools and infrastructure, seems to be too great for the benefit of occasionally programming on a mobile device. This applies to the development of mobile and non-mobile applications alike; professional programmers who develop mobile applications still prefer to use large screens and physical keyboards. Instead, we focus on easy ways to use existing languages, such as Java, on mobile devices. Our proposed solution, called \textbf{Deverywhere}, addresses both challenges, by using templates to make voice and touch input very effective for programming, and for showing much more code in a limited space. Templates, used in context, allow voice input for creating, editing, and navigation; and allow a compact representation of programs that makes maximum use of the given screen space. Both uses require a high degree of configuration, since programmers have different preferences regarding the way they want to voice and see programs. The underlying representation is always the original language, so that each programmer can see a tailored view while seamlessly collaborating on the same code with others.

These ideas are also relevant to programming on laptop and desktop systems, for people with disabilities such as repetitive-stress injuries (RSI) that limit keyboard usage, and partial vision loss, which requires the use of very large fonts. For some programmers, no screen is large enough, and so we expect that these programmers will use the compact representation of code even on large displays.
\section{Background}
In-order to create such an IDE we need to investigate several areas. The first one is, what are the features that we need in such a developing environment? The second one is, how do programmers tend to describe the code that they want to insert? And the third one is, how can we create a new representation of the code without harming the understanding of it? We need to investigate all those areas in order to design a new environment for developing with a new approach that uses voice and touch gestures.

Several studies have been published that have related to this problem. Some of the studies deal more with research and some deal essentially with application. Susan L. Graham and Andrew Begel from Berkeley University worked on a project named \textit{SPEED}. In their study they developed an add-on that integrates into Eclipse and allows the programmer to insert lines of Java code using speech. Sihan Li, Tao Xie (North Carolina State University) and Nikolai Tillman (Microsoft Research) worked on TouchDevelop. This project provides a simple and clear environment which allows the developer to develop application directly on mobile devices using touch gesture. Dennis Strein and Hans Kratz developed appfour, an IDE that runs on mobile devices. The user can compile applications directly on the  mobile device and run them.

None of the works that are described above provides a comfortable solution for IDE on mobile devices that is fully integrable with stationary computers. None of the works addresses the issue of lack of keyboards and small screen. 	Our work addresses this issue by providing a comfortable IDE which uses voice, touch and compact representation of the code.

Dictation systems exist today, but their use for programming is limited. Lacking any domain knowledge, they require most of the program to be dictated letter by letter, which is impractical. By building an understanding of program syntax and some semantics into the dictation tool, it is possible to make this process much more efficient.
\section{Problem Formulation}
Programming on mobile devices presents two major obstacles: the lack of a physical keyboard, and the small screen space, which limits the amount of code that can be shown simultaneously. This work addresses both challenges, and offers a method to enable programming on mobile and other devices with limited input and output capabilities. The method uses templates to make voice and touch input very effective for programming, and showing much more code in a limited space. These ideas are also relevant to programming on laptop and desktop systems, for people with disabilities such as repetitive-stress injuries (RSI) that limit keyboard usage, and partial vision loss, which requires the use of very large fonts. 

In this work we concentrate on several targets: design of a new representation of the code so it will fit on mobile screens and will be readable as well; Creation of a set of templates that will allow the programmer to program by dictating the code; and allow the user to configure the representation of the code.
\section{Literature Survey}
In the following list we present the main books and articles that relate to problems that are related to our area of research:

\begin{itemize}
	\item It is shown in \citet[Chap. 2]{andrew11} that programmers ran into problems of orally expressing their thoughts when they had to dictate a program. This information is very important to us and consequently we designed our experiments based on it.
	\item It is shown in \citet[Chap. 3]{andrew11} how spoken Java is processed. They developed several tools for analyzing the semantics and syntax of spoken Java. We are interested in studying the Harmonia tool for our research as well as integrating it in our system.
	\item \citet{harmonia} provide all the information about how to use the Harmonia tool and how to integrate it in programming tools. It is useful information for our future work.
	\item It is shown in \citet[Programming By Voice and Touch]{yishai13} the basic ideas and concepts of our work. Basically, this paper is the starting point for this research.
\end{itemize}
\section{Objectives}
The main objectives are the following:

\begin{enumerate}
	\item Design the representation of the code in compact mode.
	\item Design a concept for configuring language features. It needs to be comfortable and intuitive for the user.
	\item Perform a series of experiments with different volunteers. The purposes of those experiments are to understand how programmers pronounce the code that they want to insert. What are the most negligible actions that programmers take?
	\item Based on the experiments, define a set of templates that will be used as a tool to identify programmersâ€™ commands and transform them into lines of code.
	\item Search and investigate existing programming features. The features that we look for are those which are related to the Java and generally to programming. All those features have the potential to be integrated into the system.
	\item Build a prototype that proves that developing code on mobile devices is possible.
	\item Provide a solid foundation for future works based on this research.
\end{enumerate}
\section{Limitations}
Our study has several limitations which are summarized in the following list: 
\begin{itemize}
	\item This project requires a lot of coding work. Since I'm the only programmer, the implementation will be very limited.
	\item The analysis part is very long and difficult. It might require a lot of time of the research.
	\item Not many studies have been done which relate to the field "Developing on Mobile Devices" or "Developing using Voice". Therefore, we don't have many resources that we can depend upon, or from which we can learn. Most the work will have to do on our own.
	\item To implement this system a knowledge of NLP is required. We might need to study this field in order to use tools from it.
\end{itemize}
\section{Approach}
In this section I provide the scientific approach for each objective (the objectives and the approaches are correlated by the numbers of the times in the list):
\begin{enumerate}
	\item We will study the most common and major domains of programming features that exist in Java. Afterward we will collect enough programming features covering enough domains and will study other languages to determine how those features are represented there. We will search in related works for new ideas for representations and will have discussions about new those ideas. After all those processes are completed we will design a new compact representation.
	\item We need to study the most common programming features and collect them into categories. We need to design methods to configure programming features. Thereafter we will have before us the programming features of both groups which will allow us to determine how the of members from the second group are related to  elements from the first group.
	\item We will build a series of experiments which will represent a different style of programming. For example, we will utilize object oriented, and algorithmic programming styles. There will be two programmers, the typist and the speaker. The speaker will request from the typist to create a program that is already written in Java. The speaker will dictate the program and the typist will type it. After all experiments are accomplished we will compare the source and the reference (dictated program). Furthermore, we will analyze the differences between the desired and the actual results.
	\item We will extract all commands that have been dictated during the experiments. We will group them into sets, for each set we will create a template that represents this group.
	\item Schedule a series of team meetings. During every meeting the members of the group will suggest programming features that can be integrated into the system. Every feature will be discussed. All features that have been chosen will be saved in an archive.
	\item I will build a text file that contains a set of commands. Every command is a simulation of a dictation that the programmer pronounced. I will build a set of rules that know how to handle the commands.
\end{enumerate}
\section{Structure of the Report}
\begin{remark}
Write here the structure of the document.
\end{remark}