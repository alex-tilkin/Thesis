\chapter{Compact Representation}
\section{Introduction}
Programming languages weren't designed to be presented on small screens, and therefore when you try to present programs on small screens it is difficult to read them. Programming languages are textual, and so require a keyboard In order to edit programs. Standard on-screen keyboards are inconvenient for texting, let alone for programming. In addition, they require one third of the screen which makes the small screen even smaller. Our approach is to use conventional languages such as Java and C++, but allow each programmer to have a tailored compact view that fits a small screen. We believe that we should support programmers better in doing what they already know how to do instead of requiring them to learn a new language and tools only for the purpose of sometimes developing code on mobile phones. Deverywhere is not a new language; it is a way for each programmer to see the code in the way that makes the most sense to him or her. Our solution for small screens is a compact representation of the code, which means focusing on the important information necessary to understand the code. 

This chapter discusses how the code can be presented in compact representation. It covers most of the major domains of programming idioms. Every topic that discussed in this chapter is accompanied with an explanation how it will be configurable by the user and examples of is provided by default.
\section{Operators}
This section discusses how atomic operators will be represented. Every symbol may be modified by the user to any character or icon that s/he wants.
\subsection{Basic Operators}
\autoref{tab12} provides a set of basic atomic operators that used in almost every line of code.

\begin{table}[H]
\centering
\begin{tabular}{|l|l|}
\hline
{\bf Operator} & {\bf Symbol} \\ \hline
Plus & + \\ \hline
Minus & - \\ \hline
Multiplication & * \\ \hline
Division & / \\ \hline
Modulo & \% \\ \hline
Increment & ++ \\ \hline
Decrement & - - \\ \hline
Null & $ \perp $ \\ \hline
Shift & $ \ll $; $ \gg $; $ \ggg $ \\ \hline
Relational & <; >; $ \leq $; $ \geq $ \\ \hline
Equality & =; $ \neq $ \\ \hline
Bitwise AND & \& \\ \hline
Bitwise exclusive OR & $ \textasciicircum $ \\ \hline
Bitwise inclusive OR & | \\ \hline
Logical AND & $ \wedge $  \\ \hline
Logical OR & $ \vee $  \\ \hline
Ternary & ?; : \\ \hline
Assignment & $ \longleftarrow $; +$ \longleftarrow $; -$ \longleftarrow $; *$ \longleftarrow $; /$ \longleftarrow $; \%$ \longleftarrow $; \&$ \longleftarrow $; $ \wedge $$ \longleftarrow $; $ \vee $$ \longleftarrow $; $ \ll $$ \longleftarrow $; $ \gg $$ \longleftarrow $; $ \ggg $$ \longleftarrow $\\ \hline
\end{tabular}
\caption{This table presents operators and symbols that represent them in compact representation. The symbols are examples for how symbols may be presented. The user may modify to any representation that s/he wants. This idea is discussed in \autoref{chapter:Representation Configuration}. Note: ; is used as a separator between operator symbols.}
\label{tab12}
\end{table}
\section{Statement Terminators}
A statement terminator is used to demarcate the end of an individual statement. For example, a statement terminator in Java is ';' (semicolon) similarly to C, C++ and other programming languages. This character doesn't gives any information except where the statement end. The programmer will be able to modify the symbol, s/he may decide if it will be displayed or how will it looks like, e.g., result $ \longleftarrow $ nextNode.data, this is a line of code that missing statement terminator symbol. It is also possible to modify the style of the terminators or to use an icon.
\section{Mathematical Expressions}
Mathematical expressions are very common in programming. Sometimes they can be very long and complex. Therefore, we would like to represent those expressions in more compact and native way. We can reduce expressions length by changing mathematical expressions representation to native mathematical representation, e.g., $ (a-b)/(c-d) \longleftarrow \frac{a-b}{c-d} $.
\section{Boolean expressions}
This section discuses compact representation of boolean expressions.
\subsection{Range}
In-order to check if an integer is in a range the programmer needs write to write $ 0 <= i \&\& i < 10 $. We propose to write this expression in a natural representation, it will save space and will be easier for reading. For example, $ 0 \leq i < 10 $.
\section{Scopes}
This section discusses ideas of how the programmer may modify the representation of a scope.
\subsection{Scope Brackets}
The programmer may omit the brackets then the indentation of the code will denote the scope of the code. \autoref{fig32} presents a small example of code without scope brackets.
\begin{figure}[H]
\begin{lstlisting}
age = 10 ?
	adult $ \longleftarrow $ false
	isChild $ \longleftarrow $ true
\end{lstlisting}
\caption{This is an example of a control block that checks if the age is smaller than 10 then the false is assigned to the identifier \textit{adult} and true is assigned to the identifier \textit{isChild}.}
\label{fig32}
\end{figure}
\subsection{Frame}
\autoref{fig32} shows that both lines of code related to the condition because they have the same indentation. In-addition it is possible to frame the scope. It may help the programmer to understand scopes better. \ref{fig33} presents how frame can be used to represent scopes.
\begin{figure}[H]
\includegraphics{"./fig/Condition With Frame"}
\caption{This is the same code that presented in \autoref{fig32} but a frame is used to represent a scope.}
\label{fig33}
\end{figure}
\subsection{Indentation}
It is also possible to reduce the number of spaces.
\begin{figure}[H]
\includegraphics{"./fig/Condition With Frame and short Indentation"}
\caption{This is the same code that presented in \autoref{fig33} but with a shorter indentation.}
\label{fig34}
\end{figure}
The programmer may modify frame's border color, background color, border width, and border style.
\subsection{Line Break}
Line breaks have an influence on the length and the width of the code. Therefore, we would like to provide several different representations for line breaking.
\subsubsection{New Line}
Every block of code starts in the same line with the condition key word. \autoref{fig35} presents an example of this style.
\begin{figure}[H]
\begin{lstlisting}
if [condition]
then [code_1]
else [code_2]
[code_3]
\end{lstlisting}
\caption{This is a style where every block of code starts in the same line with the condition key word.}
\label{fig35}
\end{figure}
\subsubsection{2 Columns} \label{subsubsection: 2 Columns}
In this representation the \textit{then} and the \textit{else} are below the if expression but placed side by side. \autoref{fig36} presents an example of this style.
\begin{figure}[H]
\begin{lstlisting}
if [condition]
then  [code_1] else [code_2]
	   [code_1]        [code_2]
				 		    [code_2]
\end{lstlisting}
\caption{This is a style where the \textit{then} and the \textit{else} are below the if expression but placed side by side.}
\label{fig36}
\end{figure}
\subsection{Fill}
This configuration is quite identical to \autoref{subsubsection: 2 Columns} but here if one of the code blocks is longer than the other it will catch the whole line. \autoref{fig37} presents an example of this style.
\begin{figure}[H]
\begin{lstlisting}
if [condition]
then  [code_1] else [code_2]
	   [code_1]       [code_2]
[			code_2			     ]
[			code_2			     ]
\end{lstlisting}
\caption{This is a style where if one of the code blocks is longer than the other it will catch the whole line.}
\label{fig37}
\end{figure}
\section{Accessibilities}
The programmer may change the accessibility of classes, and attributes, For instance, they can be presented in the default way, e.g., \textit{public, private, protected, internal} or they can be presented with symbols as show in \autoref{tab13}. Also, it is possible to color the symbols:
$ \textcolor{green}{+}, \textcolor{red}{-}, \textcolor{yellow}{\textasciitilde}, \textcolor{blue}{\pm} $. Moreover, the programmer may ignore symbols and just color the identifier, e.g., \textcolor{red}{head} will stand for private, \textcolor{green}{iterator} will stand for public. It is also possible to use icons instead.
\begin{table}[H]
\centering
\begin{tabular}{|l|l|}
\hline
{\bf Operator} & {\bf Symbol} \\ \hline
Public & + \\ \hline
Private & - \\ \hline
Protected & $ \pm $ \\ \hline
Internal & $ \textasciitilde $ \\ \hline
\end{tabular}
\caption{This table represents possible representations for accessibilities.}
\label{tab13}
\end{table}
\section{Implementation and Inheritance}
Instead of using long terms such as: \textit{Implements}, and \textit{inherits} the programmer may change the text to a more compact representation, e.g., ":" from C++. It is Also possible to use text or icon.
\section{Types}
\subsection{Style}
The programmer may modify the style of types, e.g., change int to \textit{\textcolor{red}{int}}.
\subsection{Text Value}
The programmer may modify the textual value of types, e.g., change int to integer.
\subsection{Omit Types}
In-order to save space the programmer may hide types, access level, modifier and show only identifiers. Since types are hidden the programmer may not understand what is the type of the identifier. In-order to avoid ambiguity we suggest a technique that when an object is created the name of the identifier will be the same as the type (but the first letter will be in lowercase), e.g., private Person \_person will be presented \textcolor{red}{person} (the \textcolor{red}{Red} color denotes that this is a private field and the \textit{italic} denotes that it is static).
\section{Fields}
The programmer may configure that every field that is created will has a specific prefix or postfix, e.g., if the user configured the prefix to be "\_" and asked to create the field \textit{car} the system will write "\_car". The programmer may configure that all fields will have a certain style, e.g., \_car.
\section{Methods}
This section discusses compact representation of methods.
\subsection{Omit Returned Type}
Returned types is important for compilation but also it provides information to the programmer what type is returned from methods. This information may be omitted because it is not needed to be presented. \autoref{fig38} shows an example of a method that its returned type is hidden.
\begin{figure}[H]
\begin{lstlisting}
foo(int a)
	return a
\end{lstlisting}
\caption{The returned type (in this case it is int) is omitted.}
\label{fig38}
\end{figure}
\subsection{Omit Types of Formal Parameters}
In addition the programmer may omit types of formal parameters of methods. \autoref{39} shows the same method that is presented in \autoref{fig38} but without the type of its formal parameter.
\begin{figure}[H]
\begin{lstlisting}
foo(a)
	return a
\end{lstlisting}
\caption{The type of the formal parameter is omitted.}
\label{fig39}
\end{figure}
\subsection{Omit Parentheses}
If a method doesn't has formal parameters it is possible to omit its Parentheses. \autoref{40} shows a method that doesn't has formal parameters hence its parentheses are omitted.
\begin{figure}[H]
\includegraphics{"./fig/foo with omitted parentheses"}
\caption{This is method that its parentheses are omitted. The icon of the mobile phone denotes that the text "Hello, world!" will be printed to the console.}
\label{fig40}
\end{figure}
\subsection{Constructors}
