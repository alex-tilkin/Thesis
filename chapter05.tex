\chapter{Programming in Natural Language}
\section{Introduction}
Programming languages are textual, and so require a keyboard In order to edit programs. Standard on-screen keyboards are inconvenient for texting, let alone for programming. In addition, they take almost one third of the screen which makes the small screen even smaller. In order to avoid using the inconvenient on-screen keyboard or an external device, we suggest to program by voice. Voice dictation is based on a common set of templates; these templates are individually customizable so that each developer can use the idioms that are most convenient for him or her.

We describe the idea of programming in natural language by writing requirements in order to bridge the gap between the code that the programmer wants to write and a code that is written on the screen. We claim that natural language can serve as the main tool for programming. We do not claim that it is the only tool, the programmer may use other gestures such as touch, on-screen keyboard, or external devices when he need them.

\section{Configuration}
We suggest that every programmer will dictate his program the way is more convenient to him or her. Every one of us has a different way of describing the things that s/he want to say. Same with dictating code. 

For example take the Java loop in \autoref{fig17}. We would dictate it character by character: "for, open parenthesis, int, space etc.". This is inconvenient and cumbersome. Instead, we would like to forget about the syntax and just describe what you want. One way to say it is: "for i from zero to n". But other programmer may prefer to say "repeat n times" to describe the same loop. 

We don't just dictate code from top to bottom; we also need to edit existing code and navigate to specific places in the code. Navigation depends on the context of what is shown on the screen, and on the surrounding code. For example, if the screen contains only one loop, I can say "Go to the loop". Or I could say "Rename the index of the first loop to j" to navigate to the first loop on the screen and change its index variable. This demonstrates that templates used for dictation has named parts, and I can refer to these parts when I issue editing or navigation commands.
\begin{figure}[H]
\begin{lstlisting}
for(int i = 0; i < n; i++)
\end{lstlisting}
\caption{A simple for loop}
\label{fig17}
\end{figure}
\section{Natural Language Requirements Processing}
To recall, a context-free grammar (CFG) is a tuple $ G=(T, N, S, R) $, where $ T $ is the finite set of  terminals of the language, $ N $ is the set of non-terminals that represent phrases in a sentence, $ S \in N $ is the start variable used to represent a full sentence in the language, and $ R $ is the set of production rules of the form $ N \rightarrow (N \bigcup T)* $. The LSC grammar is defined similarly, with the addition of $ T = T_{s} \cup T_{d} $, where $ T_{s} $ is a finite set of static terminals with semantics specific to the LSC language, $ T_{d} $ is a dynamic finite set of terminals that is created foe each system, and $ T_{s}\cap T_{d} = \emptyset $.