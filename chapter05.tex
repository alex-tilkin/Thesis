\chapter{Programming in Natural Language}
\section{Introduction}
Programming languages are textual, and so require a keyboard In order to edit programs. Standard on-screen keyboards are inconvenient for texting, let alone for programming. In addition, they take almost one third of the screen which makes the small screen even smaller. In order to avoid using the inconvenient on-screen keyboard or an external device, we suggest to program by voice. Voice dictation is based on a common set of templates; these templates are individually customizable so that each developer can use the idioms that are most convenient for him or her.

We describe the idea of programming in natural language by writing requirements in order to bridge the gap between the code that the programmer wants to write and a code that is written on the screen. We claim that natural language can serve as the main tool for programming. We do not claim that it is the only tool, the programmer may use other gestures such as touch, on-screen keyboard, or external devices when he needs them.

\section{Configuration}
We suggest that every programmer will dictate his program the way is more convenient to him or her. Every one of us has a different way of describing the things that s/he want to say. Same with code dictation.

For example take the Java loop in \autoref{fig17}. We would dictate it character by character: "for, open parenthesis, int, space etc.". This is inconvenient and cumbersome. Instead, we would like to forget about the syntax and just describe what you want. One way to say it is: "for i from zero to n". But other programmer may prefer to say "repeat n times" to describe the same loop.

We don't just dictate code from top to bottom; we also need to edit existing code and navigate to specific places in the code. Navigation depends on the context of what is shown on the screen, and on the surrounding code. For example, if the screen contains only one loop, I can say "Go to the loop". Or I could say "Rename the index of the first loop to j" to navigate to the first loop on the screen and change its index variable. This demonstrates that templates used for dictation has named parts, and I can refer to these parts when I issue editing or navigation commands.
\begin{figure}[H]
\begin{lstlisting}
for(int i = 0; i < n; i++)
\end{lstlisting}
\caption{A simple for loop}
\label{fig17}
\end{figure}
\section{Natural Language Processing}
In-order to process dictation we suggest two phase process: converting speech to text, and understanding the context of the text. We use speech to text engine for the speech conversion and context free grammar to understand the  context.
\subsection{Speech To Text Engines}
We found several speech to text engines that we can use for our solution: Nuance Dragon \cite{Nuance14} is a software developer kit (SDK) is used by developers and integrators to add speech recognition capabilities into in-house and commercial applications or workflow applications. This toolkit, which enables everything from free-text dictation to command and control functionality, can be deployed as part of a server- or client-based solution; Kaldi \cite{Povey_ASRU2011} is a toolkit for speech recognition written in C++ and licensed under the Apache License v2.0. Kaldi is intended for use by speech recognition researchers. Google Speech Server V2 \cite{google15} is a an online free speech to text engine which runs on a server. Mostly used by researchers. We decided to use Google Speech Server V2 because it is free and easy to use. There are much more speech to text engines but we decided to concentrate on the most known and the one that we choose to use.
\subsection{Context Free Grammar}
A context-free grammar (CFG) is a tuple $ G=(T,N,S,R) $, where $ T $ is the finite set of  terminals of the language, $ N $ is the set of non-terminals that represent phrases in a sentence, $ S \in N $ is the start variable used to represent a full sentence in the language. $ R $ is the set of production rules of the form $ N \rightarrow (N \bigcup T)* $.
\subsubsection{Extended Backus Naur Form}
Extended Backus Naur Form is a notation for formally describing syntax how to write entities in language. The metalanguage is based on a suggestion by Niklaus Wirth (Wirth, 1977) that is based on Backus-Naur Form and that contains the most common extensions, i.e:
\begin{itemize}
	\item Terminal symbols of the language are quoted so that any character,
	including one used in Extended BNF, can be defined as a terminal symbol of
	the language being defined.
	\item $ [ $ and $ ] $ indicate optional symbols.
	\item $ \{ $ and $ \} $ indicate repetition.
	\item Each rule has an explicit final character so that there is never any
	ambiguity about where a rule ends.
	\item Brackets group items together. It is an obvious convenience to use ( and ) in their ordinary mathematical sense.
\end{itemize}
\subsection{Dictation Parser}
We use EBNF to create a set of rules that will validate commands that the programmer dictates. This set of rules can be extended easily by every user that understand EBNF. We use IEEE\\IEC EBNF \cite{IEEEBNF1996} as our main reference to learn how to use EBNF. In \cite[pages 51-86]{Michal2009} Michal Gordon and David Harel claim that formal structured natural language requirements can serve as the mean and the end to programming the behavior of reactive system using fully executable languages such as live sequence charts (LSC). We adopt this approach and use it to create a set of rules to process user dictation.

\subsubsection{Grammar Construction}
We now show how our grammar translates controlled natural language. Since we allow a CFG we can increment the grammar with additional rules that allow various ways of generating similar constructs. We can thus increase the set of accepted specifications by augmenting the grammar. However, ambiguity may grow as the grammar grows which would require the user to explicitly disambiguate his intentions in too many cases for the process to be friendly. We shall describe how basic commands such as: creation, navigation, and modification are parsed. The \textit{Dictation Parser} tries to build a parse tree for every dictation that it receives. A valid dictation is a one that the \textit{Diction Parser} succeeded to create a parse tree for. A number of advanced ideas are not yet supported in the current implementation. Nevertheless, the current grammar allows implementing fully executable systems, and has been tested, among other examples, on the \textit{LinkList} Example, and on the \textit{Command Pattern} Example.

The set of rules is divided into three main layers: \textit{Top}, \textit{Categories}, and \textit{Common}. The \textit{Top} layer contains rules that have access to all categories. The Categories layer contains sub sections that divided to different categories. For example, the \textit{Creation} sub section contains all rules that deal with creation. The \textit{Common} layer knows nothing about any category, it contains all the necessary information for all actions. The \textit{Top} layer and the \textit{Categories} layer have access to the \textit{Common} layer. \ref{fig19} shows how rules divided into layers and sub categories. Note that this division has no effect on the action of rules. It is only to understand the set of rules better.

We now shall explain every sub category inside the \textit{Categories} layer. \textit{Creation} contains all rules that parse any creation dictation. For example, "Create a new class". \textit{Navigation} contains all rules that parse any navigation dictation. For example, "Go to class person". \textit{Modification} contains all rules that parse any modification dictation.

Figure 4 displays the parse tree for the requirement: “when the user clicks the
b button, the light turns to on”. For example, "Rename class person to driver".
\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{./fig/BNFDiagram}
\caption{This is the architecture of the Dictation Parser rules}
\label{fig19}
\end{figure}
\autoref{tab11} .
\begin{table}[H]
	\centering
	\label{my-label}
	\begin{tabular}{|p{10cm}|p{6cm}|}
		\hline
		\rowcolor[HTML]{9B9B9B} 
		{\color[HTML]{000000} Rule} & {\color[HTML]{000000} Description} \\ \hline
		<Command> ::= <Creation-Command> | <Navigation-Command> | <Modification-Command> | <Selection-Command>& bla \\ \hline
		<Creation-Command> ::= <Creation-Verb> [(an | a)] (<Create-Statement> | <Create-Data-Type> | <Create-Field> | <Create-Method> | <Create-Block>) [<Element-Location>]&     \\ \hline
		&     \\ \hline
		&     \\ \hline
	\end{tabular}
	\caption{}
	\label{tab11}
\end{table}

\begin{figure}[H]
	\begin{lstlisting}
	for(int i = 0; i < n; i++)
	\end{lstlisting}
	\caption{A simple for loop}
	\label{fig20}
\end{figure}